#!/usr/bin/env python3
"""
Intent Parser Agent using Fetch.ai uAgents framework
Exposes REST API endpoint for parsing natural language intents
"""

from uagents import Agent, Context, Model
import json
import re
from typing import Optional

# Define request/response models for REST API
class IntentRequest(Model):
    """Request model for intent parsing"""
    user_address: str
    natural_text: str

class IntentResponse(Model):
    """Response model with parsed intent"""
    action: str
    amount: str
    token: str
    protocol: str
    chains: list
    user_address: str
    natural_text: str
    confidence: float

# Initialize the intent parser agent
intent_parser = Agent(
    name="intent_parser",
    seed="intent_parser_recovery_phrase_zk_fusion",
    port=8001,
    endpoint=["http://localhost:8001/submit"],
)

@intent_parser.on_event("startup")
async def startup(ctx: Context):
    """Log agent startup"""
    ctx.logger.info(f"ğŸ¤– Intent Parser Agent started!")
    ctx.logger.info(f"ğŸ“ Address: {ctx.agent.address}")
    ctx.logger.info(f"ğŸŒ Listening on port 8001")
    ctx.logger.info(f"ğŸ“ REST endpoint: POST http://localhost:8001/parse")

def parse_intent_with_rules(text: str) -> dict:
    """
    Rule-based intent parsing with pattern matching
    Returns parsed intent components
    """
    text_lower = text.lower()
    
    # Default values
    result = {
        "action": "supply",
        "amount": "100",
        "token": "USDC",
        "protocol": "morpho",
        "chains": ["optimism"],
        "confidence": 0.5
    }
    
    # Action detection (order matters - check specific actions first)
    if any(word in text_lower for word in ["withdraw", "remove", "unstake"]):
        result["action"] = "withdraw"
        result["confidence"] = 0.8
    elif "deposit" in text_lower:
        result["action"] = "deposit"
        result["confidence"] = 0.8
    elif any(word in text_lower for word in ["supply", "lend", "provide"]):
        result["action"] = "supply"
        result["confidence"] = 0.8
    elif any(word in text_lower for word in ["borrow", "take", "loan"]):
        result["action"] = "borrow"
        result["confidence"] = 0.8
    elif any(word in text_lower for word in ["swap", "exchange", "trade"]):
        result["action"] = "swap"
        result["confidence"] = 0.8
    elif any(word in text_lower for word in ["bridge", "transfer", "move"]):
        result["action"] = "bridge"
        result["confidence"] = 0.8
    
    # Amount extraction
    amount_match = re.search(r'\b(\d+(?:\.\d+)?)\b', text)
    if amount_match:
        result["amount"] = amount_match.group(1)
        result["confidence"] += 0.1
    
    # Token detection
    tokens = ["usdc", "usdt", "dai", "weth", "eth", "wbtc", "btc"]
    for token in tokens:
        if token in text_lower:
            result["token"] = token.upper()
            result["confidence"] += 0.1
            break
    
    # Protocol detection
    protocols = {
        "morpho": ["morpho"],
        "aave": ["aave"],
        "compound": ["compound"],
        "uniswap": ["uniswap", "uni"],
        "balancer": ["balancer"],
    }
    for protocol, keywords in protocols.items():
        if any(kw in text_lower for kw in keywords):
            result["protocol"] = protocol
            result["confidence"] += 0.1
            break
    
    # Chain detection
    detected_chains = []
    chain_map = {
        "optimism": ["optimism", "op"],
        "arbitrum": ["arbitrum", "arb"],
        "base": ["base"],
        "polygon": ["polygon", "matic"],
        "ethereum": ["ethereum", "eth mainnet"],
    }
    for chain, keywords in chain_map.items():
        if any(kw in text_lower for kw in keywords):
            detected_chains.append(chain)
            result["confidence"] += 0.05
    
    if detected_chains:
        result["chains"] = detected_chains
    
    # Cap confidence at 1.0
    result["confidence"] = min(result["confidence"], 1.0)
    
    return result

@intent_parser.on_rest_post("/parse", IntentRequest, IntentResponse)
async def handle_parse_intent(ctx: Context, req: IntentRequest) -> IntentResponse:
    """
    REST endpoint handler for intent parsing
    POST /parse with JSON body: {user_address, natural_text}
    """
    print("\n" + "="*70)
    print("ğŸ¤– uAGENT IS PROCESSING THIS REQUEST!")
    print("="*70)
    ctx.logger.info(f"ğŸ“¥ Received intent parsing request for user: {req.user_address}")
    ctx.logger.info(f"ï¿½ Natural text: {req.natural_text}")
    print(f"ğŸ‘¤ User: {req.user_address}")
    print(f"ğŸ’¬ Text: {req.natural_text}")
    
    try:
        # Parse the intent using rule-based system
        parsed = parse_intent_with_rules(req.natural_text)

@intent_parser.on_message(model=IntentRequest)
async def handle_intent_message(ctx: Context, sender: str, msg: IntentRequest):
    """
    Alternative message handler for agent-to-agent communication
    """
    ctx.logger.info(f"ğŸ“¨ Received intent message from agent {sender}")
    
    parsed = parse_intent_with_rules(msg.natural_text)
    
    # Send response back to sender
    response = IntentResponse(
        action=parsed["action"],
        amount=parsed["amount"],
        token=parsed["token"],
        protocol=parsed["protocol"],
        chains=parsed["chains"],
        user_address=msg.user_address,
        natural_text=msg.natural_text,
        confidence=parsed["confidence"]
    )
    
    await ctx.send(sender, response)

@intent_parser.on_interval(period=60.0)
async def log_status(ctx: Context):
    """Log agent status every minute"""
    ctx.logger.info(f"ğŸ’š Intent Parser Agent is running - Ready to parse intents!")

if __name__ == "__main__":
    print("ğŸš€ Starting Intent Parser Agent...")
    print("ğŸ“ HTTP Server: http://localhost:8001")
    print("ğŸ“ REST Endpoint: POST http://localhost:8001/parse")
    print("=" * 60)
    intent_parser.run()
